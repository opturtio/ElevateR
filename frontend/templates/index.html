<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport meta tag to ensure responsiveness on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Descriptive title for the page -->
    <title>ElevateR</title>
    
    <!-- External CSS files for Leaflet and other dependencies -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/leaflet.awesome-markers.css') }}" />
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/style.css') }}" />
    
    <!-- External JS libraries: Leaflet.js for maps and MarkerCluster plugin -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
    <script src="{{ url_for('static', filename='js/leaflet.awesome-markers.js') }}"></script>

    <!-- Custom HeatMap JS -->
    <script src="{{ url_for('static', filename='js/simpleheat.js') }}"></script> <!-- Simpleheat must come first -->
    <script src="{{ url_for('static', filename='js/HeatLayer.js') }}"></script>
    
</head>
<body>
    <!-- Header elements for the map application -->
    <h1>ElevateR</h1>
    <h3>Elevation Map for Public Transport Travel Time</h3>

    <!-- Button for triggering an elevation calculation (example functionality) -->
    <button id="elevateButton">Elevate</button>

    <!-- Map container where Leaflet will render the map -->
    <div id="map"></div>

    <script>
        let selectedLat = null;
        let selectedLon = null;
        let heatmapLayer = null;  // Declare a global variable for the heatmap layer
    
        // Initialize the map with a view centered on Helsinki
        const map = L.map('map').setView([60.170677, 24.941514], 12);
    
        // Add OpenStreetMap tiles to the map (basic map rendering)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
    
        // Create a cluster group to handle marker clustering with specific options
        const markers = L.markerClusterGroup({
            maxClusterRadius: 40, 
            spiderfyOnMaxZoom: false, 
            zoomToBoundsOnClick: true, 
            showCoverageOnHover: true, 
            animate: true,
            removeOutsideVisibleBounds: true,  
            disableClusteringAtZoom: 14, 
            spiderLegPolylineOptions: { 
                weight: 0.5, 
                color: '#222',
                opacity: 0.3
            },
        });
    
        // Fetching station data (assumed to be injected server-side using Jinja templating)
        const stations = JSON.parse('{{ stations | tojson | safe }}');
    
        const vehicleTypes = {
            0: 'Tram',
            1: 'Metro',
            109: 'Train',
            3: 'Bus',
            4: 'Ferry',
        }
    
        // Arrays to store markers for different types of vehicles
        const busTramMarkers = [];
        const nonBusTramMarkers = [];
    
        // Function to return marker color based on the vehicle type
        function getMarkerColor(vehicleType) {
            switch (vehicleType) {
                case 0:
                    return 'green';  // Tram
                case 1:
                    return 'orange'; // Metro
                case 109:
                    return 'red';    // Train
                case 3:
                    return 'blue';   // Bus
                case 4:
                    return 'purple'; // Ferry
                default:
                    return 'gray';   // Default color for unknown/other types
            }
        }
    
        // Loop through all the stations and create markers accordingly
        stations.forEach(station => {
            const markerColor = getMarkerColor(station.vehicleType);
            const vehicleIcons = {
                0: 'fa-subway',     
                1: 'fa-subway',     
                109: 'fa-train',    
                3: 'fa-bus',        
                4: 'fa-ship',       
            };
    
            // Create a colored marker using the AwesomeMarkers plugin
            const coloredMarker = L.AwesomeMarkers.icon({
                icon: vehicleIcons[station.vehicleType],
                markerColor: markerColor,
                prefix: 'fa'
            });
    
            // Create the marker with the corresponding popup for station details
            const marker = L.marker([station.lat, station.lon], { icon: coloredMarker })
                .bindPopup(`${station.name} (${vehicleTypes[station.vehicleType]})`)
                .on('click', function() {
                    selectedLat = station.lat;
                    selectedLon = station.lon;
                });
    
            if (station.vehicleType === 0 || station.vehicleType === 3) {
                busTramMarkers.push(marker);
            } else {
                nonBusTramMarkers.push(marker);
                marker.addTo(map);
            }
        });
    
        // Add all non-bus/tram markers to the map at the beginning
        nonBusTramMarkers.forEach(marker => marker.addTo(map));
    
        // Initially add all bus and tram markers to the cluster group
        map.addLayer(markers);
        busTramMarkers.forEach(marker => {
            markers.addLayer(marker);
        });
    
        // Event listener for when the zoom starts
        map.on('zoomstart', function() {
            const currentZoom = map.getZoom();
            const zoomThreshold = 14;
    
            if (currentZoom <= zoomThreshold) {
                busTramMarkers.forEach(marker => marker.removeFrom(map));
            }
        });
    
        // Event listener for when zooming ends
        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            const zoomThreshold = 14;
    
            if (currentZoom <= zoomThreshold) {
                busTramMarkers.forEach(marker => markers.addLayer(marker));
            } else {
                busTramMarkers.forEach(marker => {
                    markers.removeLayer(marker);
                    marker.addTo(map);
                });
            }
        });
    
        document.getElementById('elevateButton').addEventListener('click', function() {
            if (selectedLat && selectedLon) {
                // Send a POST request to trigger the elevation process with the selected station's lat/lon
                fetch('/elevate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        lat: selectedLat,
                        lon: selectedLon
                    })
                })
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error('Failed to trigger elevation process');
                    }
                })
                .then(data => {
                    alert('Elevation process triggered successfully!');
    
                    const maxTravelTime = Math.max(...data.map(station => station.travel_time));
                    const minTravelTime = Math.min(...data.map(station => station.travel_time));
    
                    // Remove existing heatmap layer if it exists
                    if (heatmapLayer) {
                        map.removeLayer(heatmapLayer);
                    }
    
                    // Step 1: Prepare heatmap data using the station data returned from the backend
                    const heatmapData = data.map(station => {
                        let travelTimeNormalized = (station.travel_time - minTravelTime) / (maxTravelTime - minTravelTime);
                        travelTimeNormalized = Math.min(Math.max(travelTimeNormalized, 0), 1);
                        return [station.lat, station.lon, travelTimeNormalized];
                    });
                    console.log("Heatmap Data:", heatmapData);

                    // Step 2: Create and add the heatmap layer to the map
                    heatmapLayer = L.heatLayer(heatmapData, {
                        radius: 150,
                        blur: 120,         
                        opacity: 0.1,
                        maxZoom: 12,        
                        gradient: {         
                            0.0: 'lightblue',    
                            0.25: 'blue',
                            0.5: 'yellow', 
                            0.75: 'orange',     
                            1.0: 'red'   
                        }
                    }).addTo(map);
                })
                .catch(error => {
                    console.error('Error during elevation process:', error);
                    alert('Error during elevation process.');
                });
            } else {
                alert('Please select a station on the map.');
                console.warn("No station selected on the map.");
            }
        });
    </script>
    
</body>
</html>
