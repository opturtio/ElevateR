<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport meta tag to ensure responsiveness on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Descriptive title for the page -->
    <title>ElevateR</title>
    
    <!-- External CSS files for Leaflet and other dependencies -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- Including local custom stylesheets (relative paths using Jinja templating) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/leaflet.awesome-markers.css') }}" />
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/style.css') }}" />
    
    <!-- External JavaScript libraries: Leaflet.js for maps, and MarkerCluster plugin -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
    <script src="{{ url_for('static', filename='js/leaflet.awesome-markers.js') }}"></script>
</head>
<body>
    <!-- Header elements for the map application -->
    <h1>ElevateR</h1>
    <h3>Elevation Map for Public Transport Travel Time</h3>

    <!-- Button for triggering an elevation calculation (example functionality) -->
    <button id="elevateButton">Elevate</button>

    <!-- Map container where Leaflet will render the map -->
    <div id="map"></div>

    <script>
        let selectedLat = null;
        let selectedLon = null;
    
        // Initialize the map with a view centered on Helsinki
        const map = L.map('map').setView([60.170677, 24.941514], 12);
    
        // Add OpenStreetMap tiles to the map (basic map rendering)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
    
        // Create a cluster group to handle marker clustering with specific options
        const markers = L.markerClusterGroup({
            maxClusterRadius: 40,  // Defines how close markers need to be to cluster together
            spiderfyOnMaxZoom: false,  // Allows clusters to expand (spiderfy) when clicked
            zoomToBoundsOnClick: true,  // Prevents zooming in when clicking on clusters
            showCoverageOnHover: true,  // Shows the cluster coverage area when hovering over clusters
            animate: true,  // Enable animation for smoother clustering/unclustering
            removeOutsideVisibleBounds: true,  // Removes markers that are outside the visible map bounds for performance optimization
            disableClusteringAtZoom: 14,  // Disables clustering beyond zoom level 14, showing individual markers
            spiderLegPolylineOptions: { 
                weight: 0.5,  // Sets the thickness of the spider leg lines
                color: '#222',  // Specifies a dark gray color for the spider leg lines
                opacity: 0.3  // Sets the transparency of the spider leg lines
            },
        });
    
        // Fetching station data (assumed to be injected server-side using Jinja templating)
        const stations = JSON.parse('{{ stations | tojson | safe }}');
    
        const vehicleTypes = {
            0: 'Tram',
            1: 'Metro',
            109: 'Train',
            3: 'Bus',
            4: 'Ferry',
        }
    
        // Arrays to store markers for different types of vehicles
        const busTramMarkers = [];
        const nonBusTramMarkers = [];
    
        // Function to return marker color based on the vehicle type
        function getMarkerColor(vehicleType) {
            switch (vehicleType) {
                case 0:
                    return 'green';  // Tram
                case 1:
                    return 'orange'; // Metro
                case 109:
                    return 'red';    // Train
                case 3:
                    return 'blue';   // Bus
                case 4:
                    return 'purple'; // Ferry
                default:
                    return 'gray';   // Default color for unknown/other types
            }
        }
    
        // Loop through all the stations and create markers accordingly
        stations.forEach(station => {
            // Determine the color based on the station's vehicle type
            const markerColor = getMarkerColor(station.vehicleType);
            
            // Create an icon for marker by transport type using the AwesomeMarkers plugin
            const vehicleIcons = {
                0: 'fa-subway',      // Tram
                1: 'fa-subway',      // Metro
                109: 'fa-train',     // Train
                3: 'fa-bus',         // Bus
                4: 'fa-ship',        // Ferry
            };
    
            // Create a colored marker using the AwesomeMarkers plugin
            const coloredMarker = L.AwesomeMarkers.icon({
                icon: vehicleIcons[station.vehicleType],
                markerColor: markerColor,
                prefix: 'fa'
            });
            
            // Create the marker with the corresponding popup for station details
            const marker = L.marker([station.lat, station.lon], { icon: coloredMarker })
                .bindPopup(`${station.name} (${vehicleTypes[station.vehicleType]})`)
                .on('click', function() {
                    // Capture the selected station's lat/lon
                    selectedLat = station.lat;
                    selectedLon = station.lon;
                });
    
            // Separate bus and tram markers from other vehicle markers for specific behavior
            if (station.vehicleType === 0 || station.vehicleType === 3) {
                busTramMarkers.push(marker);
            } else {
                nonBusTramMarkers.push(marker);
                marker.addTo(map);
            }
        });
    
        // Add all non-bus/tram markers to the map at the beginning
        nonBusTramMarkers.forEach(marker => marker.addTo(map));
    
        // Initially add all bus and tram markers to the cluster group
        map.addLayer(markers);
        busTramMarkers.forEach(marker => {
            markers.addLayer(marker);
        });
    
        // Event listener for when the zoom starts
        map.on('zoomstart', function() {
            const currentZoom = map.getZoom();
            const zoomThreshold = 14;
    
            if (currentZoom <= zoomThreshold) {
                // Remove individual bus and tram markers before zooming out (if zoomed out enough)
                busTramMarkers.forEach(marker => marker.removeFrom(map));
            }
        });
    
        // Event listener for when zooming ends
        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            const zoomThreshold = 14;
    
            if (currentZoom <= zoomThreshold) {
                // If zoomed out enough (zoom level 14 or lower), add bus/tram markers to the cluster
                busTramMarkers.forEach(marker => {
                    markers.addLayer(marker); // Add bus/tram markers to the cluster
                });
            } else {
                // If zoomed in beyond level 14, display bus/tram markers individually
                busTramMarkers.forEach(marker => {
                    markers.removeLayer(marker); // Remove from cluster
                    marker.addTo(map);  // Add back to map individually
                });
            }
        });
    
        document.getElementById('elevateButton').addEventListener('click', function() {
            if (selectedLat && selectedLon) {
                // Send a POST request to trigger the elevation process with the selected station's lat/lon
                fetch('/elevate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        lat: selectedLat,
                        lon: selectedLon
                    })
                })
                .then(response => {
                    if (response.ok) {
                        return response.json(); // Parse the JSON response if the request is successful
                    } else {
                        throw new Error('Failed to trigger elevation process');
                    }
                })
                .then(data => {
                    alert('Elevation process triggered successfully!');

                    // Find the maximum travel time from the returned data to normalize intensity
                    const maxTravelTime = Math.max(...data.map(station => station.travel_time));
                    console.log("Max travel time:", maxTravelTime); // Debugging log to check max travel time

                    // Find the minimum travel time for proper normalization (in case you want a spectrum from min to max)
                    const minTravelTime = Math.min(...data.map(station => station.travel_time));
                    console.log("Min travel time:", minTravelTime); // Debugging log to check min travel time

                    // Step 1: Prepare heatmap data using the station data returned from the backend
                    const heatmapData = data.map(station => {
                        // Normalize the travel time to a value between 0 and 1
                        let travelTimeNormalized = (station.travel_time - minTravelTime) / (maxTravelTime - minTravelTime);
                        
                        // Ensure value is clamped between 0 and 1
                        travelTimeNormalized = Math.min(Math.max(travelTimeNormalized, 0), 1);

                        console.log(`Station ${station.station_name} - Normalized travel time:`, travelTimeNormalized); // Debugging log

                        // Return the [lat, lon, intensity] for the heatmap
                        return [station.lat, station.lon, travelTimeNormalized];
                    });

                    // Debugging log to check the full heatmap data
                    console.log("Heatmap Data:", heatmapData);

                    // Step 2: Create and add the heatmap layer to the map
                    const heatmapLayer = L.heatLayer(heatmapData, {
                        radius: 50,          // Larger radius for better visibility of the heatmap
                        blur: 40,            // Increased blur for smoother transitions
                        opacity: 0.8,        // Overall opacity of the heatmap layer
                        maxZoom: 12,         // Maximum zoom level for the heatmap to be visible
                        gradient: {          // Custom color gradient based on travel time
                            0.0: 'lightblue',    // Shortest travel time
                            0.25: 'blue',
                            0.5: 'orange', 
                            0.75: 'red',     // Medium travel time
                            1.0: 'darkred'   // Longest travel time
                        }
                    }).addTo(map);
                })
                .catch(error => {
                    console.error('Error during elevation process:', error); // Log error details for debugging
                    alert('Error during elevation process.');
                });
            } else {
                alert('Please select a station on the map.');
                console.warn("No station selected on the map.");
            }
        });
    </script>
</body>
</html>
